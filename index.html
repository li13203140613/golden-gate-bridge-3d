<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Gate Bridge 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            color: #fff;
            width: 240px;
            border: 1px solid rgba(255, 107, 53, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 100;
        }
        #controls h2 {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #ff6b35;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 107, 53, 0.3);
        }
        .control-group {
            margin-bottom: 18px;
        }
        .control-group label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }
        .control-group label span {
            color: #ff6b35;
            font-weight: 600;
        }
        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #2a2a4a, #3a3a5a);
            border-radius: 3px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, #ff6b35, #ff8855);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.5);
            transition: transform 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 1000;
            transition: opacity 0.5s;
        }
        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loader {
            width: 60px;
            height: 60px;
            border: 3px solid #2a2a4a;
            border-top-color: #ff6b35;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #loading p {
            color: #ff6b35;
            margin-top: 20px;
            font-size: 14px;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="loader"></div>
        <p>Loading Golden Gate Bridge...</p>
    </div>
    <div id="canvas-container"></div>
    <div id="controls">
        <h2>Golden Gate Bridge</h2>
        <div class="control-group">
            <label>Time of Day <span id="time-val">14:00</span></label>
            <input type="range" id="time" min="0" max="24" step="0.1" value="14">
        </div>
        <div class="control-group">
            <label>Fog Density <span id="fog-val">30%</span></label>
            <input type="range" id="fog" min="0" max="100" step="1" value="30">
        </div>
        <div class="control-group">
            <label>Traffic <span id="traffic-val">50%</span></label>
            <input type="range" id="traffic" min="0" max="100" step="1" value="50">
        </div>
        <div class="control-group">
            <label>Camera Zoom <span id="zoom-val">300</span></label>
            <input type="range" id="zoom" min="100" max="600" step="10" value="300">
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 5000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 100;
        controls.maxDistance = 800;
        controls.maxPolarAngle = Math.PI * 0.45;
        controls.minPolarAngle = Math.PI * 0.05;
        camera.position.set(350, 180, 400);
        controls.target.set(0, 50, 0);

        // Post-processing
        const composer = new THREE.EffectComposer(renderer);
        const renderPass = new THREE.RenderPass(scene, camera);
        composer.addPass(renderPass);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            0.6, 0.4, 0.85
        );
        composer.addPass(bloomPass);

        // State
        let timeOfDay = 14;
        let fogDensity = 0.3;
        let trafficDensity = 0.5;
        let targetZoom = 300;

        // Sky colors
        const skyColors = {
            night: new THREE.Color(0x0a0a1a),
            dawn: new THREE.Color(0xff6b35),
            day: new THREE.Color(0x87ceeb),
            sunset: new THREE.Color(0xff4444)
        };

        // Fog color interpolation
        function getSkyColor(time) {
            const t = time;
            const color = new THREE.Color();

            if (t >= 5 && t < 7) {
                const f = (t - 5) / 2;
                color.lerpColors(skyColors.night, skyColors.dawn, f);
            } else if (t >= 7 && t < 10) {
                const f = (t - 7) / 3;
                color.lerpColors(skyColors.dawn, skyColors.day, f);
            } else if (t >= 10 && t < 16) {
                color.copy(skyColors.day);
            } else if (t >= 16 && t < 19) {
                const f = (t - 16) / 3;
                color.lerpColors(skyColors.day, skyColors.sunset, f);
            } else if (t >= 19 && t < 21) {
                const f = (t - 19) / 2;
                color.lerpColors(skyColors.sunset, skyColors.dawn, f);
            } else {
                color.copy(skyColors.night);
            }
            return color;
        }

        function getFogColor(time) {
            const t = time;
            const color = new THREE.Color();

            if (t >= 5 && t < 7) {
                const f = (t - 5) / 2;
                color.lerpColors(skyColors.night, new THREE.Color(0xffaa88), f);
            } else if (t >= 7 && t < 10) {
                color.setHex(0xccddff);
            } else if (t >= 10 && t < 16) {
                color.setHex(0xaaccff);
            } else if (t >= 16 && t < 19) {
                color.lerpColors(new THREE.Color(0xaaccff), new THREE.Color(0xff8866), (t - 16) / 3);
            } else {
                color.lerpColors(new THREE.Color(0xff8866), skyColors.night, Math.min(1, (t - 19) / 3));
            }
            return color;
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(100, 200, 100);
        sunLight.castShadow = false;
        scene.add(sunLight);

        const sunSphere = new THREE.Mesh(
            new THREE.SphereGeometry(15, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        scene.add(sunSphere);

        // Fog
        scene.fog = new THREE.FogExp2(0xaaccff, 0.002);

        // Water shader
        const waterGeometry = new THREE.PlaneGeometry(3000, 3000, 128, 128);
        const waterMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uSunPosition: { value: new THREE.Vector3(100, 200, 100) },
                uSunColor: { value: new THREE.Color(0xffffff) },
                uFogColor: { value: new THREE.Color(0xaaccff) },
                uFogDensity: { value: 0.002 },
                uCameraPosition: { value: camera.position },
                uWaterColor: { value: new THREE.Color(0x0a3a5a) },
                uShallowColor: { value: new THREE.Color(0x1a6f8a) }
            },
            vertexShader: `
                uniform float uTime;
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying float vElevation;

                void main() {
                    vec3 pos = position;
                    float wave1 = sin(pos.x * 0.01 + uTime * 0.5) * 2.0;
                    float wave2 = sin(pos.y * 0.015 + uTime * 0.3) * 1.5;
                    float wave3 = sin((pos.x + pos.y) * 0.008 + uTime * 0.7) * 1.0;
                    pos.z += wave1 + wave2 + wave3;
                    vElevation = pos.z;
                    float dx = cos(pos.x * 0.01 + uTime * 0.5) * 0.02 * 2.0;
                    float dy = cos(pos.y * 0.015 + uTime * 0.3) * 0.015 * 1.5;
                    vNormal = normalize(vec3(-dx, -dy, 1.0));
                    vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * viewMatrix * worldPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 uSunPosition;
                uniform vec3 uSunColor;
                uniform vec3 uFogColor;
                uniform float uFogDensity;
                uniform vec3 uCameraPosition;
                uniform vec3 uWaterColor;
                uniform vec3 uShallowColor;
                varying vec3 vWorldPosition;
                varying vec3 vNormal;
                varying float vElevation;

                void main() {
                    vec3 viewDir = normalize(uCameraPosition - vWorldPosition);
                    vec3 normal = normalize(vNormal);
                    float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);
                    vec3 lightDir = normalize(uSunPosition);
                    vec3 halfDir = normalize(lightDir + viewDir);
                    float spec = pow(max(dot(normal, halfDir), 0.0), 256.0);
                    float depth = length(vWorldPosition.xz) * 0.001;
                    vec3 waterCol = mix(uShallowColor, uWaterColor, min(depth, 1.0));
                    waterCol += vec3(0.1, 0.15, 0.2) * (vElevation * 0.1 + 0.5);
                    vec3 reflectColor = mix(uFogColor, vec3(0.8, 0.9, 1.0), 0.3);
                    vec3 color = mix(waterCol, reflectColor, fresnel * 0.6);
                    color += uSunColor * spec * 2.0;
                    float dist = length(vWorldPosition - uCameraPosition);
                    float fogFactor = 1.0 - exp(-uFogDensity * uFogDensity * dist * dist);
                    color = mix(color, uFogColor, fogFactor);
                    gl_FragColor = vec4(color, 0.95);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });

        const water = new THREE.Mesh(waterGeometry, waterMaterial);
        water.rotation.x = -Math.PI / 2;
        water.position.y = -5;
        scene.add(water);

        // Bridge materials
        const bridgeColor = new THREE.Color(0xc0362c);
        const bridgeMaterial = new THREE.MeshStandardMaterial({
            color: bridgeColor,
            roughness: 0.7,
            metalness: 0.1
        });

        // Bridge deck
        function createDeck() {
            const deckGroup = new THREE.Group();
            const deckGeo = new THREE.BoxGeometry(1400, 8, 27);
            const deck = new THREE.Mesh(deckGeo, bridgeMaterial);
            deck.position.y = 65;
            deckGroup.add(deck);
            const roadGeo = new THREE.BoxGeometry(1400, 1, 22);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.9 });
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.position.y = 69;
            deckGroup.add(road);
            const laneMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            for (let i = -600; i < 600; i += 40) {
                const laneGeo = new THREE.BoxGeometry(15, 0.5, 0.5);
                const lane = new THREE.Mesh(laneGeo, laneMat);
                lane.position.set(i, 69.5, 0);
                deckGroup.add(lane);
            }
            return deckGroup;
        }

        // Bridge towers
        function createTower(x) {
            const towerGroup = new THREE.Group();
            const sections = [
                { w: 10, h: 60, y: 30 },
                { w: 12, h: 40, y: 85 },
                { w: 14, h: 50, y: 130 },
                { w: 16, h: 60, y: 175 },
                { w: 18, h: 70, y: 235 }
            ];
            sections.forEach(s => {
                const geo = new THREE.BoxGeometry(s.w, s.h, 12);
                const mesh = new THREE.Mesh(geo, bridgeMaterial);
                mesh.position.y = s.y;
                towerGroup.add(mesh);
            });
            const braceMat = new THREE.MeshStandardMaterial({ color: 0x8a2520, roughness: 0.6 });
            for (let y = 80; y < 260; y += 30) {
                const braceGeo = new THREE.BoxGeometry(2, 2, 16);
                const brace = new THREE.Mesh(braceGeo, braceMat);
                brace.position.set(0, y, 0);
                towerGroup.add(brace);
            }
            const crownGeo = new THREE.BoxGeometry(20, 8, 14);
            const crown = new THREE.Mesh(crownGeo, bridgeMaterial);
            crown.position.y = 270;
            towerGroup.add(crown);
            towerGroup.position.x = x;
            return towerGroup;
        }

        // Main cable
        function createMainCable() {
            const points = [];
            const towerY = 270;
            const sag = 100;
            for (let x = -600; x <= 600; x += 10) {
                const dist = Math.abs(x);
                const y = towerY - sag * Math.cos((dist / 600) * Math.PI / 2);
                points.push(new THREE.Vector3(x, Math.max(y, towerY - sag), 0));
            }
            const curve = new THREE.CatmullRomCurve3(points);
            const geo = new THREE.TubeGeometry(curve, 100, 1.5, 8, false);
            const cable = new THREE.Mesh(geo, bridgeMaterial);
            return cable;
        }

        // Suspender cables
        function createSuspenderCables() {
            const group = new THREE.Group();
            const cableMat = new THREE.MeshStandardMaterial({ color: 0x8a2520 });
            for (let x = -550; x <= 550; x += 25) {
                const dist = Math.abs(x);
                const towerY = 270;
                const cableY = towerY - 100 * Math.cos((dist / 600) * Math.PI / 2);
                const y = Math.max(cableY, towerY - 100);
                const height = y - 65;
                if (height > 10) {
                    const geo = new THREE.CylinderGeometry(0.3, 0.3, height, 6);
                    const cable = new THREE.Mesh(geo, cableMat);
                    cable.position.set(x, 65 + height / 2, 0);
                    group.add(cable);
                }
            }
            return group;
        }

        // Piers
        function createPier(x) {
            const group = new THREE.Group();
            const pierMat = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
            const geo = new THREE.BoxGeometry(20, 50, 18);
            const pier = new THREE.Mesh(geo, pierMat);
            pier.position.y = -20;
            group.add(pier);
            const baseGeo = new THREE.BoxGeometry(30, 10, 25);
            const base = new THREE.Mesh(baseGeo, pierMat);
            base.position.y = 5;
            group.add(base);
            group.position.x = x;
            return group;
        }

        // Anchors
        function createAnchor(x) {
            const group = new THREE.Group();
            const anchorMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            const geo = new THREE.BoxGeometry(40, 30, 30);
            const anchor = new THREE.Mesh(geo, anchorMat);
            anchor.position.y = 25;
            group.add(anchor);
            group.position.x = x;
            return group;
        }

        // Add bridge components
        const deck = createDeck();
        scene.add(deck);
        const tower1 = createTower(-128);
        const tower2 = createTower(128);
        scene.add(tower1);
        scene.add(tower2);
        const mainCable = createMainCable();
        scene.add(mainCable);
        const suspenders = createSuspenderCables();
        scene.add(suspenders);
        const pier1 = createPier(-400);
        const pier2 = createPier(400);
        scene.add(pier1);
        scene.add(pier2);
        const anchor1 = createAnchor(-650);
        const anchor2 = createAnchor(650);
        scene.add(anchor1);
        scene.add(anchor2);

        // Bridge lights
        const bridgeLights = [];
        function createBridgeLights() {
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffaa44 });
            for (let x = -600; x <= 600; x += 50) {
                const light = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 8),
                    lightMat.clone()
                );
                light.position.set(x, 60, 14);
                scene.add(light);
                bridgeLights.push(light);
                const glow = new THREE.PointLight(0xffaa44, 0.5, 30);
                glow.position.copy(light.position);
                scene.add(glow);
            }
        }
        createBridgeLights();

        // Terrain
        function createTerrain() {
            const terrainGroup = new THREE.Group();
            const marinGeo = new THREE.PlaneGeometry(1500, 800, 64, 64);
            const positions = marinGeo.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const y = positions[i + 1];
                let height = 0;
                if (x < -200) {
                    height = Math.sin(x * 0.01) * 30 + Math.cos(y * 0.02) * 20 + 50;
                    height += Math.random() * 5;
                }
                positions[i + 2] = height;
            }
            marinGeo.computeVertexNormals();
            const marinMat = new THREE.MeshStandardMaterial({
                color: 0x3a5a3a,
                roughness: 0.9,
                flatShading: true
            });
            const marin = new THREE.Mesh(marinGeo, marinMat);
            marin.rotation.x = -Math.PI / 2;
            marin.position.set(-600, 0, -500);
            terrainGroup.add(marin);
            const sfGeo = new THREE.PlaneGeometry(1500, 400, 32, 32);
            const sfPositions = sfGeo.attributes.position.array;
            for (let i = 0; i < sfPositions.length; i += 3) {
                const x = sfPositions[i];
                sfPositions[i + 2] = Math.sin(x * 0.01) * 10 + 10;
            }
            sfGeo.computeVertexNormals();
            const sfMat = new THREE.MeshStandardMaterial({ color: 0x4a4a4a, roughness: 0.8 });
            const sf = new THREE.Mesh(sfGeo, sfMat);
            sf.rotation.x = -Math.PI / 2;
            sf.position.set(200, 0, 350);
            terrainGroup.add(sf);
            return terrainGroup;
        }
        const terrain = createTerrain();
        scene.add(terrain);

        // City buildings
        const buildings = [];
        function createCity() {
            const buildingMat = new THREE.MeshStandardMaterial({
                color: 0x555566,
                roughness: 0.7,
                metalness: 0.2
            });
            for (let i = 0; i < 150; i++) {
                const width = 10 + Math.random() * 20;
                const height = 15 + Math.random() * 60;
                const depth = 10 + Math.random() * 20;
                const geo = new THREE.BoxGeometry(width, height, depth);
                const building = new THREE.Mesh(geo, buildingMat.clone());
                const x = 100 + Math.random() * 600;
                const z = 200 + Math.random() * 300;
                building.position.set(x, height / 2, z);
                scene.add(building);
                buildings.push({ mesh: building, height: height, windows: [] });
                const windowRows = Math.floor(height / 8);
                const windowCols = Math.floor(width / 6);
                for (let r = 0; r < windowRows; r++) {
                    for (let c = 0; c < windowCols; c++) {
                        if (Math.random() > 0.3) {
                            const win = new THREE.Mesh(
                                new THREE.PlaneGeometry(2, 3),
                                new THREE.MeshBasicMaterial({ color: 0xffffcc })
                            );
                            win.position.set(
                                x - width/2 + 3 + c * 6,
                                3 + r * 8,
                                z + depth/2 + 0.1
                            );
                            win.userData.isWindow = true;
                            scene.add(win);
                            buildings[buildings.length - 1].windows.push(win);
                        }
                    }
                }
            }
        }
        createCity();

        // Cars
        const MAX_CARS = 400;
        const carGeometry = new THREE.BoxGeometry(6, 2.5, 3);
        const carColors = [0xff4444, 0x4444ff, 0xffffff, 0x333333, 0xffcc00, 0x00aa44, 0xff6600];

        // Create instanced mesh with different materials per instance workaround
        const carMesh = new THREE.InstancedMesh(carGeometry, new THREE.MeshStandardMaterial({ color: 0xffffff }), MAX_CARS);
        carMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        scene.add(carMesh);

        const carData = [];
        for (let i = 0; i < MAX_CARS; i++) {
            const lane = Math.floor(Math.random() * 6) - 2.5;
            const direction = Math.random() > 0.5 ? 1 : -1;
            const color = carColors[Math.floor(Math.random() * carColors.length)];
            carData.push({
                x: (Math.random() - 0.5) * 1300,
                lane: lane * 3.5,
                direction: direction,
                speed: 0.3 + Math.random() * 0.4,
                color: color,
                active: true
            });
        }

        function updateCars(count, time) {
            const isNight = time < 6 || time > 19;
            carMesh.count = Math.floor(count * MAX_CARS);
            const matrix = new THREE.Matrix4();
            const color = new THREE.Color();

            for (let i = 0; i < MAX_CARS; i++) {
                if (i >= carMesh.count) {
                    matrix.makeScale(0, 0, 0);
                    carMesh.setMatrixAt(i, matrix);
                    continue;
                }
                const car = carData[i];
                car.x += car.speed * car.direction;
                if (car.direction > 0 && car.x > 680) car.x = -680;
                if (car.direction < 0 && car.x < -680) car.x = 680;
                matrix.makeTranslation(car.x, 67, car.lane);
                carMesh.setMatrixAt(i, matrix);
                color.setHex(car.color);
                carMesh.setColorAt(i, color);
            }
            carMesh.instanceMatrix.needsUpdate = true;
            if (carMesh.instanceColor) carMesh.instanceColor.needsUpdate = true;
        }

        // Ships
        const ships = [];
        function createShips() {
            for (let i = 0; i < 4; i++) {
                const shipGroup = new THREE.Group();
                const hullGeo = new THREE.BoxGeometry(80, 15, 20);
                const hullMat = new THREE.MeshStandardMaterial({ color: 0x333344 });
                const hull = new THREE.Mesh(hullGeo, hullMat);
                hull.position.y = 5;
                shipGroup.add(hull);
                const containerMat = new THREE.MeshStandardMaterial({ color: 0xaa5544 });
                for (let c = 0; c < 6; c++) {
                    const container = new THREE.Mesh(
                        new THREE.BoxGeometry(10, 8, 18),
                        containerMat
                    );
                    container.position.set(-25 + c * 10, 18, 0);
                    shipGroup.add(container);
                }
                const redLight = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                redLight.position.set(-35, 12, -8);
                shipGroup.add(redLight);
                shipGroup.userData.redLight = redLight;
                const greenLight = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
                );
                greenLight.position.set(-35, 12, 8);
                shipGroup.add(greenLight);
                shipGroup.userData.greenLight = greenLight;
                const whiteLight = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffffff })
                );
                whiteLight.position.set(0, 28, 0);
                shipGroup.add(whiteLight);
                shipGroup.userData.whiteLight = whiteLight;
                const redNav = new THREE.PointLight(0xff0000, 0.5, 20);
                redNav.position.copy(redLight.position);
                shipGroup.add(redNav);
                const greenNav = new THREE.PointLight(0x00ff00, 0.5, 20);
                greenNav.position.copy(greenLight.position);
                shipGroup.add(greenNav);
                shipGroup.userData.redNav = redNav;
                shipGroup.userData.greenNav = greenNav;
                shipGroup.position.set(
                    (Math.random() - 0.5) * 1500,
                    0,
                    (Math.random() - 0.5) * 800 - 200
                );
                shipGroup.userData.direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    0,
                    (Math.random() - 0.5) * 0.02
                ).normalize();
                scene.add(shipGroup);
                ships.push(shipGroup);
            }
        }
        createShips();

        function updateShips(time) {
            const isNight = time < 6 || time > 19;
            ships.forEach(ship => {
                ship.position.add(ship.userData.direction);
                if (ship.position.x > 1000) ship.position.x = -1000;
                if (ship.position.x < -1000) ship.position.x = 1000;
                if (ship.position.z > 500) ship.position.z = -500;
                if (ship.position.z < -500) ship.position.z = 500;
                ship.userData.redNav.intensity = isNight ? 1 : 0;
                ship.userData.greenNav.intensity = isNight ? 1 : 0;
            });
        }

        // Birds
        const MAX_BIRDS = 50;
        const birdGeometry = new THREE.ConeGeometry(1.5, 4, 4);
        birdGeometry.rotateX(Math.PI / 2);
        const birdMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const birdMesh = new THREE.InstancedMesh(birdGeometry, birdMaterial, MAX_BIRDS);
        scene.add(birdMesh);

        const birdData = [];
        for (let i = 0; i < MAX_BIRDS; i++) {
            birdData.push({
                position: new THREE.Vector3(
                    (Math.random() - 0.5) * 400,
                    150 + Math.random() * 100,
                    (Math.random() - 0.5) * 400
                ),
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 2
                )
            });
        }

        function updateBirds(delta) {
            const center = new THREE.Vector3(0, 180, 0);
            const matrix = new THREE.Matrix4();

            for (let i = 0; i < MAX_BIRDS; i++) {
                const bird = birdData[i];
                const separation = new THREE.Vector3();
                const alignment = new THREE.Vector3();
                const cohesion = new THREE.Vector3();
                let count = 0;

                for (let j = 0; j < MAX_BIRDS; j++) {
                    if (i === j) continue;
                    const dist = bird.position.distanceTo(birdData[j].position);
                    if (dist < 30) {
                        separation.sub(birdData[j].position).normalize().divideScalar(dist);
                        alignment.add(birdData[j].velocity);
                        cohesion.add(birdData[j].position);
                        count++;
                    }
                }

                if (count > 0) {
                    alignment.divideScalar(count).normalize().multiplyScalar(0.03);
                    cohesion.divideScalar(count).sub(bird.position).normalize().multiplyScalar(0.01);
                    separation.multiplyScalar(0.05);
                }
                const toCenter = center.clone().sub(bird.position).normalize().multiplyScalar(0.02);
                bird.velocity.add(separation).add(alignment).add(cohesion).add(toCenter);
                bird.velocity.clampLength(0, 2);
                bird.position.add(bird.velocity);
                bird.position.x = Math.max(-400, Math.min(400, bird.position.x));
                bird.position.y = Math.max(100, Math.min(300, bird.position.y));
                bird.position.z = Math.max(-400, Math.min(400, bird.position.z));
                matrix.makeTranslation(bird.position.x, bird.position.y, bird.position.z);
                const lookAt = bird.position.clone().add(bird.velocity);
                matrix.lookAt(bird.position, lookAt, new THREE.Vector3(0, 1, 0));
                birdMesh.setMatrixAt(i, matrix);
            }
            birdMesh.instanceMatrix.needsUpdate = true;
        }

        // Update day/night
        function updateDayNight(time) {
            const isNight = time < 6 || time > 19;
            const sunIntensity = isNight ? 0 : Math.sin((time - 6) / 12 * Math.PI) * 1.5;
            const ambientIntensity = isNight ? 0.1 : 0.3 + Math.sin((time - 6) / 12 * Math.PI) * 0.2;
            sunLight.intensity = sunIntensity;
            ambientLight.intensity = ambientIntensity;
            const sunAngle = ((time - 6) / 12) * Math.PI;
            const sunX = Math.cos(sunAngle) * 300;
            const sunY = Math.sin(sunAngle) * 300;
            sunLight.position.set(sunX, Math.max(sunY, 10), 50);
            sunSphere.position.copy(sunLight.position);
            if (isNight) {
                sunSphere.material.color.setHex(0x4444aa);
                sunLight.color.setHex(0x6666aa);
            } else if (time < 7 || time > 18) {
                sunSphere.material.color.setHex(0xff6644);
                sunLight.color.setHex(0xffaa66);
            } else {
                sunSphere.material.color.setHex(0xffffaa);
                sunLight.color.setHex(0xffffff);
            }
            scene.background = getSkyColor(time);
            scene.fog.color = getFogColor(time);
            bloomPass.strength = isNight ? 1.2 : 0.4;
            bridgeLights.forEach(light => {
                light.material.color.setHex(isNight ? 0xffaa44 : 0x885533);
            });
            buildings.forEach(b => {
                b.windows.forEach(win => {
                    win.material.color.setHex(isNight ? 0xffaa44 : 0xffffcc);
                });
            });
            waterMaterial.uniforms.uFogColor.value = getFogColor(time);
            waterMaterial.uniforms.uSunPosition.value.copy(sunLight.position);
        }

        // UI Controls
        document.getElementById('time').addEventListener('input', function(e) {
            timeOfDay = parseFloat(e.target.value);
            const hours = Math.floor(timeOfDay);
            const mins = Math.floor((timeOfDay - hours) * 60);
            document.getElementById('time-val').textContent = hours.toString().padStart(2, '0') + ':' + mins.toString().padStart(2, '0');
        });

        document.getElementById('fog').addEventListener('input', function(e) {
            fogDensity = parseInt(e.target.value);
            document.getElementById('fog-val').textContent = fogDensity + '%';
            scene.fog.density = fogDensity / 100 * 0.015;
            waterMaterial.uniforms.uFogDensity.value = scene.fog.density;
        });

        document.getElementById('traffic').addEventListener('input', function(e) {
            trafficDensity = parseInt(e.target.value) / 100;
            document.getElementById('traffic-val').textContent = e.target.value + '%';
        });

        document.getElementById('zoom').addEventListener('input', function(e) {
            targetZoom = parseInt(e.target.value);
            document.getElementById('zoom-val').textContent = targetZoom;
        });

        // Animation loop
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            waterMaterial.uniforms.uTime.value = time;
            waterMaterial.uniforms.uCameraPosition.value.copy(camera.position);
            updateDayNight(timeOfDay);
            updateCars(trafficDensity, timeOfDay);
            updateShips(time);
            updateBirds(delta);
            const currentDist = camera.position.distanceTo(controls.target);
            const zoomDiff = targetZoom - currentDist;
            if (Math.abs(zoomDiff) > 1) {
                const dir = camera.position.clone().sub(controls.target).normalize();
                camera.position.add(dir.multiplyScalar(zoomDiff * 0.05));
            }
            controls.update();
            composer.render();
        }

        // Handle resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        setTimeout(function() {
            document.getElementById('loading').classList.add('hidden');
        }, 1000);

        animate();
    </script>
</body>
</html>
